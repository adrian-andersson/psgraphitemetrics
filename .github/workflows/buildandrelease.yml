name: Build and Release

on:
  workflow_dispatch:
    inputs:
      version_type:
        description: 'Type of version increment'
        required: true
        default: 'none'
        type: choice
        options:
          - major
          - minor
          - patch
          - none
      release_type:
        description: 'Type of release'
        required: true
        default: 'prerelease'
        type: choice
        options:
          - stable
          - prerelease
      moduleforge_release_toggle:
        description: 'Select ModuleForge Release Type'
        required: false
        default: 'stable'
        type: choice
        options:
          - moduleforge-latest-stable-only
          - moduleforge-latest-prerelease-allowed


jobs:
  buildAndRelease:
    runs-on: ubuntu-latest
    permissions:
      contents: write #required for pushing tags and creating releases
      packages: write #Needed for publishing to Github packages
      actions: read #Grant read access to actions and logs

    steps:

      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0 #Ensure we are getting all the tag history

      - name: Git Check
        shell: pwsh
        run: | 
          $VerbosePreference = 'Continue'
          $gitVer = git --version
          $gitFolder = git rev-parse --is-inside-work-tree
          write-verbose "GitVersion: $gitVer"
          write-verbose "IsGitWorkingDirectory: $gitFolder"

      - name: Check Pester Test Workflow status
        shell: pwsh
        env:
          REPO_URI: ${{ github.repository }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: | 
          $VerbosePreference = 'Continue'
          $workflow = 'pesterTest.yml'
          $Owner = "$env:GITHUB_REPOSITORY_OWNER"
          $Repo = "$env:GITHUB_REPOSITORY"
          write-verbose "Owner: $owner"
          write-verbose "Repo: $repo"
          $repositoryUri = "https://github.com/$($env:REPO_URI)"
          $apiUri = "https://api.github.com/repos/$Repo/actions/workflows/$Workflow/runs?per_page=2&status=completed"
          write-verbose "apiUri: $apiUri"
          $token = "${{ secrets.GITHUB_TOKEN }}"
          $headers = @{
            Authorization = "token $token"
            Accept = 'application/vnd.github.v3+json'
          }
          $WorkflowRuns = Invoke-RestMethod -Uri $apiUri -Headers $Headers -ve
          $LatestRun = $WorkflowRuns.workflow_runs | Select-Object -First 1
          if(!$latestRun){throw "❌ No $($workflow) workflows found"}
          write-verbose "LatestPesterRun Status: $($LatestRun.conclusion) LatestRun SHA: $($LatestRun.head_sha)"
          if($latestRun.conclusion -ne 'success'){
            throw "❌ The most recent Pester Test failed. Fix the issues before proceeding."
          }
          $LatestTestSHA = $LatestRun.head_sha
          $gitLog = git log --pretty=format:"%H - %s" -n 2
          #write-verbose "Git Log:`n$($gitLog|out-string)"
          $split = $gitLog[0].split(' - ')
          $lastSha = $split[0]
          $message = $split[1]
          write-verbose "Last Commit SHA: $lastSha"
          if($lastSha -eq $LatestTestSHA)
          {
            write-host '✅ Pester Test validation passed! Matched last commit'
          }elseIf($message -like 'Merge pull request*'){
            write-verbose 'Last commit was a merge. Checking previous commit'
            $split2 = $gitLog[1].split(' - ')
            $prSha = $split2[0]
            $prMessage = $split2[1]
            write-verbose "Last PR SHA: $prSha"
            if($prSha -eq $LatestTestSHA)
            {
              write-host '✅ Pester Test validation passed! Matched PR Test Commit'
            }else{
              throw "❌ The most recent Pester Test failed. Fix the issues before proceeding."
            }
          }else{
            throw "❌ No match on PR or primary commit with last Pester Test. Please check pester and try again!"
          }

      - name: Install dependencies #Install the modules we need for the build
        shell: pwsh
        run: |
          $VerbosePreference = 'Continue'
          Install-Module -Name Microsoft.PowerShell.PSResourceGet -Force -SkipPublisherCheck
          $mfReleaseType="${{ github.event.inputs.moduleforge_release_toggle }}"
          if($mfReleaseType -eq 'moduleforge-latest-prerelease-allowed')
          {
            write-verbose '********WARNING: Will use latest moduleForge, even if it is a prerelease ********'
            Install-Module -Name ModuleForge -AllowPrerelease -Force -SkipPublisherCheck
          }else{
            write-verbose 'Will use latest stable release of moduleForge'
            Install-Module -Name ModuleForge -Force -SkipPublisherCheck
          }
          $moduleList = @('Microsoft.PowerShell.PSResourceGet','ModuleForge')
          import-module $moduleList
          get-module $moduleList|Select-object Name,@{name='version';expression={if($_.PrivateData.PSData.Prerelease){"$($_.Version)-$($_.PrivateData.PSData.Prerelease)"}else{"$($_.Version)"}}}|Format-Table

      - name: Get next version and build #Execute the moduleForge command to create new module files
        shell: pwsh
        id: generate_tag
        if: success()
        run: |
          $VerbosePreference = 'Continue'
          $latest = get-mfGitLatestVersion
          #Inputs to determine next semver
          $versionType="${{ github.event.inputs.version_type }}"
          write-verbose "Version Increment Type: $versionType"
          $releaseType="${{ github.event.inputs.release_type }}"
          write-verbose "Version Release Type: $releaseType"
          $nextVerSplat = @{
            version = $latest #The current version
          }
          if($versionType -eq 'none'){
            write-verbose 'Bumping current version'
          }else{
            write-verbose "Changing $versionType version"
            $nextVerSplat.increment = $versionType
          }
          if($releaseType -eq 'prerelease'){
            write-verbose 'Adding PreRelease Tag'
            $nextVerSplat.prerelease = $true
          }else{
            write-verbose 'Stable Release'
            $nextVerSplat.stablerelease = $true
          }
          $nextVersion = get-mfNextSemver @nextVerSplat
          Write-Verbose "NEXT VERSION SHOULD BE: $nextVersion"
          write-verbose 'Compiling Changelog'
          $changeLog = get-mfGitChangeLog -fromLastTag
          Build-mfProject -version $nextVersion -InformationAction Continue -releaseNotes $changeLog
          write-verbose "Push $nextVersion to workflow as EnvVar"
          write-output "next_version=$nextVersion" >> $env:GITHUB_OUTPUT
          write-verbose "Push changeLog to workflow as EnvVar"
          #Need to do this as a special multiline value so it works correctly
          "change_log<<EOF" >> $env:GITHUB_OUTPUT
          $changeLog >> $env:GITHUB_OUTPUT
          "EOF" >> $env:GITHUB_OUTPUT

      - name: Publish to Local #Push the build from last step to a temporary file-based repository on the build machine. Add Repository to XML for GHPackages Compatibility
        shell: pwsh
        id: publish_local
        if: success()
        env:
          REPO_URI: ${{ github.repository }}
        run: |
          $VerbosePreference = 'continue'
          $repositoryUri = "https://github.com/$($env:REPO_URI)"
          write-verbose "Repository URI: $repositoryUri"
          $currentPath = get-location
          #Find the item from the build
          $psd1Ref = $(get-childItem -path ./build/ -recurse -filter '*.psd1').fullname
          if($psd1Ref)
          {
            write-verbose "Found PSD1 file: $psd1Ref"
          }else{
            throw 'No PSD1 file found'
          }

          $repositoryPath = join-path -path $currentPath -childPath 'LocalRepository'
          write-verbose "Will create local repository at path: $repositoryPath"
          if(!(test-path $repositoryPath))
          {
            new-item -itemType Directory -path $repositoryPath
          }
          register-mfLocalPsResourceRepository -path $repositoryPath
          publish-psresource -repository LocalTestRepository -path $psd1Ref

          $nuRef = (get-childItem -path $repositoryPath -recurse -filter *.nupkg).fullname
          if($nuRef)
          {
            write-verbose "Found NUPKG: $nuRef"
          }else{
            throw 'No NUPKG found'
          }
          add-mfRepositoryXmlData -repositoryUri $repositoryUri  -nugetPackagePath $nuRef

      - name: Create new tag #Create version tag
        shell: pwsh
        if: success()
        env:
          NEXT_VERSION: ${{ steps.generate_tag.outputs.next_version }}
        run: |
          $VerbosePreference = 'Continue'
          write-verbose 'Post VerbosePreference'
          Write-Verbose "Creating tag v$($env:NEXT_VERSION)"
          $ver = "v$($env:NEXT_VERSION)"
          
          if($ver -and $ver -ne 'v' -and $ver.length -ge 6)
          {
            write-verbose "Tagging Version as: $ver"
            git tag "$ver"
            git push --tags 
          }else{
            throw 'No Version Tag found'
          }

      - name: Create GitHub Release #Push the nupkg and tag as a release
        shell: pwsh
        if: success()
        env:
          NEXT_VERSION: ${{ steps.generate_tag.outputs.next_version }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CHANGE_LOG: ${{ steps.generate_tag.outputs.change_log }}
        run: |
          $VerbosePreference = 'Continue'
          $ver = "v$($env:NEXT_VERSION)"
          $releaseName = "Release $($ver)"
          #Reuse changelog from buildAndRelease step
          $markdownText = $($env:CHANGE_LOG)
          if(!$markdownText){
            $markdownText = "#Release Version: $ver`n_no changelog provided_`n"
          }
          #Get the NuPkg file to send with the release
          $currentPath = get-location
          $repositoryPath = join-path -path $currentPath -childPath 'LocalRepository'
          $nuRef = (get-childItem -path $repositoryPath -recurse -filter *.nupkg).fullname
          if($nuRef)
          {
            write-verbose "Found NUPKG: $nuRef"
          }else{
            throw 'No NUPKG found'
          }
          write-verbose 'Adding Module and Manifest SHAs to Release Notes for verification'
          # Load module name from ModuleForge config
          $moduleName = (Import-Clixml moduleForgeConfig.xml).moduleName
          # Locate the manifest and module script
          $psd1Ref = Get-ChildItem -Path build -Filter "$moduleName.psd1" -Recurse | Select-Object -First 1
          $psm1Ref = Get-ChildItem -Path build -Filter "$moduleName.psm1" -Recurse | Select-Object -First 1
          # Compute SHA256 hashes
          $psd1Sha = (Get-FileHash -Path $psd1Ref.FullName -Algorithm SHA256).Hash.ToLower()
          $psm1Sha = (Get-FileHash -Path $psm1Ref.FullName -Algorithm SHA256).Hash.ToLower()
          # Append to markdown
          $markDownText = "$($markDownText)`n### 🔐 SHA256 Checksums`n$("$moduleName").psd1: $psd1Sha `n$("$moduleName").psm1: $psm1Sha"
          gh release create $ver --title $releaseName --notes $markDownText
          gh release upload $ver $nuRef

      - name: Publish to GitHub Packages #Publish module to GH Packages
        shell: pwsh
        if: success()
        env:
          NEXT_VERSION: ${{ steps.generate_tag.outputs.next_version }}
          REPO_URI: ${{ github.repository_owner }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          $VerbosePreference = 'Continue'
          $ver = "v$($env:NEXT_VERSION)"
          $repoUri = "https://nuget.pkg.github.com/$($env:REPO_URI)/index.json"
          $currentPath = get-location
          $repositoryPath = join-path -path $currentPath -childPath 'LocalRepository'
          $nuRef = (get-childItem -path $repositoryPath -recurse -filter *.nupkg).fullname
          if($nuRef)
          {
            write-verbose "Found NUPKG: $nuRef"
          }else{
            throw 'No NUPKG found'
          }
          dotnet nuget push $nuRef -k $env:GITHUB_TOKEN -s $repoUri